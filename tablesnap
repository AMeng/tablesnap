#!/usr/bin/env python
import pyinotify
import boto

from optparse import OptionParser
from traceback import format_exc
from threading import Thread
from Queue import Queue
import logging
import os.path
import socket
import json
import sys
import os
import pwd
import grp
import time

log = logging.getLogger('tablesnap')
stderr = logging.StreamHandler()
stderr.setFormatter(logging.Formatter('%(asctime)s %(levelname)s %(message)s'))
log.addHandler(stderr)
log.setLevel(logging.DEBUG)

# Default number of writer threads
default_threads = 4

class UploadHandler(pyinotify.ProcessEvent):
    def my_init(self, threads=None, key=None, secret=None, bucket_name=None,
                prefix=None, name=None):
        self.key = key
        self.secret = secret
        self.bucket_name = bucket_name
        self.prefix = prefix
        self.name = name or socket.getfqdn()
        self.fileq = Queue()
        for i in range(threads):
            t = Thread(target=self.worker)
            t.daemon = True
            t.start()

    def build_keyname(self, pathname):
        return '%s%s:%s' % (self.prefix or '', self.name, pathname)

    def add_file(self, filename):
        if filename.find('-tmp') == -1:
            self.fileq.put(filename)

    def worker(self):
        # Reconnect to S3
        s3 = boto.connect_s3(self.key, self.secret)
        bucket = s3.get_bucket(self.bucket_name)

        while True:
            f = self.fileq.get()
            keyname = self.build_keyname(f)
            self.upload_sstable(bucket, keyname, f)
            self.fileq.task_done()

    def process_IN_MOVED_TO(self, event):
        self.add_file(event.pathname)

    def upload_sstable(self, bucket, keyname, filename, with_index=True):
        if bucket.get_key(keyname):
            log.info("Keyname %s already exists, skipping upload" % keyname)
            return

        def progress(sent, total):
            if sent == total:
                log.info('Finished uploading %s' % filename)

        try:
            log.info('Uploading %s' % filename)

            dirname = os.path.dirname(filename)
            if with_index:
                key = bucket.new_key('%s-listdir.json' % keyname)
                key.set_contents_from_string(
                    json.dumps({dirname: os.listdir(dirname)}),
                    headers={'Content-Type': 'application/json'})

            # Include the file system metadata so that we have the
            # option of using it to restore the file modes correctly.
            #
            try:
                stat = os.stat(filename)
            except OSError:
                # File removed?
                return

            meta = {'uid': stat.st_uid,
                    'gid': stat.st_gid,
                    'mode': stat.st_mode}
            try:
                u = pwd.getpwuid(stat.st_uid)
                meta['user'] = u.pw_name
            except:
                pass

            try:
                g = grp.getgrgid(stat.st_gid)
                meta['group'] = g.gr_name
            except:
                pass

            key = bucket.new_key(keyname)
            key.set_metadata('stat', json.dumps(meta))
            key.set_contents_from_filename(filename, replace=False, cb=progress)
        except:
            log.error('Error uploading %s\n%s' % (keyname, format_exc()))


def backup_files(handler, paths):
    for path in paths:
        log.info('Backing up %s' % path)
        for filename in os.listdir(path):
            if filename.find('-tmp') != -1:
                continue

            fullpath = '%s/%s' % (path, filename)
            if os.path.isdir(fullpath):
                continue

            handler.add_file(fullpath)
    return 0


def main():
    parser = OptionParser(usage='%prog [options] <bucket> <path> [...]')
    parser.add_option('-k', '--aws-key', dest='aws_key', default=None)
    parser.add_option('-s', '--aws-secret', dest='aws_secret', default=None)
    parser.add_option('-r', '--recursive', action='store_true', dest='recursive', default=False,
        help='Recursively watch the given path(s)s for new SSTables')
    parser.add_option('-a', '--auto-add', action='store_true', dest='auto_add', default=False,
        help='Automatically start watching new subdirectories within path(s)')
    parser.add_option('-p', '--prefix', dest='prefix', default=None,
        help='Set a string prefix for uploaded files in S3')
    parser.add_option('-t', '--threads', dest='threads', default=default_threads,
                      help='Number of writer threads')
    parser.add_option('-n', '--name', dest='name', default=None,
        help='Use this name instead of the FQDN to identify the SSTables from this host')
    options, args = parser.parse_args()

    if len(args) < 2:
        parser.print_help()
        return -1

    bucket = args[0]
    paths = args[1:]

    # Check S3 credentials only. We reconnect per-thread to avoid any
    # potential thread-safety problems.
    s3 = boto.connect_s3(options.aws_key, options.aws_secret)
    bucket = s3.get_bucket(bucket)

    handler = UploadHandler(threads=options.threads, key=options.aws_key,
                            secret=options.aws_secret, bucket_name=bucket,
                            prefix=options.prefix, name=options.name)

    wm = pyinotify.WatchManager()
    notifier = pyinotify.Notifier(wm, handler)
    for path in paths:
        ret = wm.add_watch(path, pyinotify.IN_MOVED_TO, rec=options.recursive,
                           auto_add=options.auto_add)
        if ret[path] == -1:
            log.critical('add_watch failed for %s, bailing out!' % path)
            return 1

    backup_files(handler, paths)

    notifier.loop()

if __name__ == '__main__':
    sys.exit(main())
